Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMA
    STRING

Grammar

Rule 0     S' -> program
Rule 1     program -> function
Rule 2     function -> INT ID LPAREN RPAREN LBRACE block RETURN NUMBER SEMICOLON RBRACE
Rule 3     block -> block statement
Rule 4     block -> empty
Rule 5     statement -> INT ID EQUAL NUMBER SEMICOLON
Rule 6     statement -> INT ID EQUAL simple_expression SEMICOLON
Rule 7     statement -> BOOL ID EQUAL simple_expression SEMICOLON
Rule 8     statement -> ID EQUAL NUMBER SEMICOLON
Rule 9     statement -> ID EQUAL simple_expression SEMICOLON
Rule 10    statement -> IF LPAREN logical_a RPAREN LBRACE block RBRACE
Rule 11    statement -> PRINT LPAREN term RPAREN SEMICOLON
Rule 12    logical_a -> logical_a OR logical_b
Rule 13    logical_a -> logical_b
Rule 14    logical_a -> TRUE
Rule 15    logical_a -> FALSE
Rule 16    logical_a -> ID
Rule 17    logical_b -> logical_b AND logical_c
Rule 18    logical_b -> logical_c
Rule 19    logical_c -> logical_c EQ logical_d
Rule 20    logical_c -> logical_c NEQ logical_d
Rule 21    logical_c -> logical_d
Rule 22    logical_d -> logical_d LE marked_expression
Rule 23    logical_d -> logical_d GE marked_expression
Rule 24    logical_d -> logical_d LT marked_expression
Rule 25    logical_d -> logical_d GT marked_expression
Rule 26    marked_expression -> expression
Rule 27    logical_d -> marked_expression
Rule 28    simple_expression -> expression
Rule 29    expression -> expression PLUS term
Rule 30    expression -> expression MINUS term
Rule 31    expression -> term
Rule 32    term -> term TIMES factor
Rule 33    term -> factor
Rule 34    factor -> NUMBER
Rule 35    factor -> TRUE
Rule 36    factor -> FALSE
Rule 37    factor -> ID
Rule 38    empty -> <empty>

Terminals, with rules where they appear

AND                  : 17
BOOL                 : 7
COMMA                : 
EQ                   : 19
EQUAL                : 5 6 7 8 9
FALSE                : 15 36
GE                   : 23
GT                   : 25
ID                   : 2 5 6 7 8 9 16 37
IF                   : 10
INT                  : 2 5 6
LBRACE               : 2 10
LE                   : 22
LPAREN               : 2 10 11
LT                   : 24
MINUS                : 30
NEQ                  : 20
NUMBER               : 2 5 8 34
OR                   : 12
PLUS                 : 29
PRINT                : 11
RBRACE               : 2 10
RETURN               : 2
RPAREN               : 2 10 11
SEMICOLON            : 2 5 6 7 8 9 11
STRING               : 
TIMES                : 32
TRUE                 : 14 35
error                : 

Nonterminals, with rules where they appear

block                : 2 3 10
empty                : 4
expression           : 26 28 29 30
factor               : 32 33
function             : 1
logical_a            : 10 12
logical_b            : 12 13 17
logical_c            : 17 18 19 20
logical_d            : 19 20 21 22 23 24 25
marked_expression    : 22 23 24 25 27
program              : 0
simple_expression    : 6 7 9
statement            : 3
term                 : 11 29 30 31 32

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . function
    (2) function -> . INT ID LPAREN RPAREN LBRACE block RETURN NUMBER SEMICOLON RBRACE

    INT             shift and go to state 3

    program                        shift and go to state 1
    function                       shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> function .

    $end            reduce using rule 1 (program -> function .)


state 3

    (2) function -> INT . ID LPAREN RPAREN LBRACE block RETURN NUMBER SEMICOLON RBRACE

    ID              shift and go to state 4


state 4

    (2) function -> INT ID . LPAREN RPAREN LBRACE block RETURN NUMBER SEMICOLON RBRACE

    LPAREN          shift and go to state 5


state 5

    (2) function -> INT ID LPAREN . RPAREN LBRACE block RETURN NUMBER SEMICOLON RBRACE

    RPAREN          shift and go to state 6


state 6

    (2) function -> INT ID LPAREN RPAREN . LBRACE block RETURN NUMBER SEMICOLON RBRACE

    LBRACE          shift and go to state 7


state 7

    (2) function -> INT ID LPAREN RPAREN LBRACE . block RETURN NUMBER SEMICOLON RBRACE
    (3) block -> . block statement
    (4) block -> . empty
    (38) empty -> .

    RETURN          reduce using rule 38 (empty -> .)
    INT             reduce using rule 38 (empty -> .)
    BOOL            reduce using rule 38 (empty -> .)
    ID              reduce using rule 38 (empty -> .)
    IF              reduce using rule 38 (empty -> .)
    PRINT           reduce using rule 38 (empty -> .)

    block                          shift and go to state 8
    empty                          shift and go to state 9

state 8

    (2) function -> INT ID LPAREN RPAREN LBRACE block . RETURN NUMBER SEMICOLON RBRACE
    (3) block -> block . statement
    (5) statement -> . INT ID EQUAL NUMBER SEMICOLON
    (6) statement -> . INT ID EQUAL simple_expression SEMICOLON
    (7) statement -> . BOOL ID EQUAL simple_expression SEMICOLON
    (8) statement -> . ID EQUAL NUMBER SEMICOLON
    (9) statement -> . ID EQUAL simple_expression SEMICOLON
    (10) statement -> . IF LPAREN logical_a RPAREN LBRACE block RBRACE
    (11) statement -> . PRINT LPAREN term RPAREN SEMICOLON

    RETURN          shift and go to state 12
    INT             shift and go to state 10
    BOOL            shift and go to state 14
    ID              shift and go to state 11
    IF              shift and go to state 15
    PRINT           shift and go to state 16

    statement                      shift and go to state 13

state 9

    (4) block -> empty .

    RETURN          reduce using rule 4 (block -> empty .)
    INT             reduce using rule 4 (block -> empty .)
    BOOL            reduce using rule 4 (block -> empty .)
    ID              reduce using rule 4 (block -> empty .)
    IF              reduce using rule 4 (block -> empty .)
    PRINT           reduce using rule 4 (block -> empty .)
    RBRACE          reduce using rule 4 (block -> empty .)


state 10

    (5) statement -> INT . ID EQUAL NUMBER SEMICOLON
    (6) statement -> INT . ID EQUAL simple_expression SEMICOLON

    ID              shift and go to state 17


state 11

    (8) statement -> ID . EQUAL NUMBER SEMICOLON
    (9) statement -> ID . EQUAL simple_expression SEMICOLON

    EQUAL           shift and go to state 18


state 12

    (2) function -> INT ID LPAREN RPAREN LBRACE block RETURN . NUMBER SEMICOLON RBRACE

    NUMBER          shift and go to state 19


state 13

    (3) block -> block statement .

    RETURN          reduce using rule 3 (block -> block statement .)
    INT             reduce using rule 3 (block -> block statement .)
    BOOL            reduce using rule 3 (block -> block statement .)
    ID              reduce using rule 3 (block -> block statement .)
    IF              reduce using rule 3 (block -> block statement .)
    PRINT           reduce using rule 3 (block -> block statement .)
    RBRACE          reduce using rule 3 (block -> block statement .)


state 14

    (7) statement -> BOOL . ID EQUAL simple_expression SEMICOLON

    ID              shift and go to state 20


state 15

    (10) statement -> IF . LPAREN logical_a RPAREN LBRACE block RBRACE

    LPAREN          shift and go to state 21


state 16

    (11) statement -> PRINT . LPAREN term RPAREN SEMICOLON

    LPAREN          shift and go to state 22


state 17

    (5) statement -> INT ID . EQUAL NUMBER SEMICOLON
    (6) statement -> INT ID . EQUAL simple_expression SEMICOLON

    EQUAL           shift and go to state 23


state 18

    (8) statement -> ID EQUAL . NUMBER SEMICOLON
    (9) statement -> ID EQUAL . simple_expression SEMICOLON
    (28) simple_expression -> . expression
    (29) expression -> . expression PLUS term
    (30) expression -> . expression MINUS term
    (31) expression -> . term
    (32) term -> . term TIMES factor
    (33) term -> . factor
    (34) factor -> . NUMBER
    (35) factor -> . TRUE
    (36) factor -> . FALSE
    (37) factor -> . ID

    NUMBER          shift and go to state 25
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    ID              shift and go to state 24

    simple_expression              shift and go to state 26
    expression                     shift and go to state 27
    term                           shift and go to state 28
    factor                         shift and go to state 29

state 19

    (2) function -> INT ID LPAREN RPAREN LBRACE block RETURN NUMBER . SEMICOLON RBRACE

    SEMICOLON       shift and go to state 32


state 20

    (7) statement -> BOOL ID . EQUAL simple_expression SEMICOLON

    EQUAL           shift and go to state 33


state 21

    (10) statement -> IF LPAREN . logical_a RPAREN LBRACE block RBRACE
    (12) logical_a -> . logical_a OR logical_b
    (13) logical_a -> . logical_b
    (14) logical_a -> . TRUE
    (15) logical_a -> . FALSE
    (16) logical_a -> . ID
    (17) logical_b -> . logical_b AND logical_c
    (18) logical_b -> . logical_c
    (19) logical_c -> . logical_c EQ logical_d
    (20) logical_c -> . logical_c NEQ logical_d
    (21) logical_c -> . logical_d
    (22) logical_d -> . logical_d LE marked_expression
    (23) logical_d -> . logical_d GE marked_expression
    (24) logical_d -> . logical_d LT marked_expression
    (25) logical_d -> . logical_d GT marked_expression
    (27) logical_d -> . marked_expression
    (26) marked_expression -> . expression
    (29) expression -> . expression PLUS term
    (30) expression -> . expression MINUS term
    (31) expression -> . term
    (32) term -> . term TIMES factor
    (33) term -> . factor
    (34) factor -> . NUMBER
    (35) factor -> . TRUE
    (36) factor -> . FALSE
    (37) factor -> . ID

    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    ID              shift and go to state 38
    NUMBER          shift and go to state 43

    logical_a                      shift and go to state 34
    logical_b                      shift and go to state 35
    logical_c                      shift and go to state 39
    logical_d                      shift and go to state 40
    marked_expression              shift and go to state 41
    expression                     shift and go to state 42
    term                           shift and go to state 28
    factor                         shift and go to state 29

state 22

    (11) statement -> PRINT LPAREN . term RPAREN SEMICOLON
    (32) term -> . term TIMES factor
    (33) term -> . factor
    (34) factor -> . NUMBER
    (35) factor -> . TRUE
    (36) factor -> . FALSE
    (37) factor -> . ID

    NUMBER          shift and go to state 43
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    ID              shift and go to state 24

    term                           shift and go to state 44
    factor                         shift and go to state 29

state 23

    (5) statement -> INT ID EQUAL . NUMBER SEMICOLON
    (6) statement -> INT ID EQUAL . simple_expression SEMICOLON
    (28) simple_expression -> . expression
    (29) expression -> . expression PLUS term
    (30) expression -> . expression MINUS term
    (31) expression -> . term
    (32) term -> . term TIMES factor
    (33) term -> . factor
    (34) factor -> . NUMBER
    (35) factor -> . TRUE
    (36) factor -> . FALSE
    (37) factor -> . ID

    NUMBER          shift and go to state 45
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    ID              shift and go to state 24

    simple_expression              shift and go to state 46
    expression                     shift and go to state 27
    term                           shift and go to state 28
    factor                         shift and go to state 29

state 24

    (37) factor -> ID .

    TIMES           reduce using rule 37 (factor -> ID .)
    PLUS            reduce using rule 37 (factor -> ID .)
    MINUS           reduce using rule 37 (factor -> ID .)
    SEMICOLON       reduce using rule 37 (factor -> ID .)
    RPAREN          reduce using rule 37 (factor -> ID .)
    LE              reduce using rule 37 (factor -> ID .)
    GE              reduce using rule 37 (factor -> ID .)
    LT              reduce using rule 37 (factor -> ID .)
    GT              reduce using rule 37 (factor -> ID .)
    EQ              reduce using rule 37 (factor -> ID .)
    NEQ             reduce using rule 37 (factor -> ID .)
    AND             reduce using rule 37 (factor -> ID .)
    OR              reduce using rule 37 (factor -> ID .)


state 25

    (8) statement -> ID EQUAL NUMBER . SEMICOLON
    (34) factor -> NUMBER .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 47
    TIMES           reduce using rule 34 (factor -> NUMBER .)
    PLUS            reduce using rule 34 (factor -> NUMBER .)
    MINUS           reduce using rule 34 (factor -> NUMBER .)

  ! SEMICOLON       [ reduce using rule 34 (factor -> NUMBER .) ]


state 26

    (9) statement -> ID EQUAL simple_expression . SEMICOLON

    SEMICOLON       shift and go to state 48


state 27

    (28) simple_expression -> expression .
    (29) expression -> expression . PLUS term
    (30) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 28 (simple_expression -> expression .)
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50


state 28

    (31) expression -> term .
    (32) term -> term . TIMES factor

    PLUS            reduce using rule 31 (expression -> term .)
    MINUS           reduce using rule 31 (expression -> term .)
    SEMICOLON       reduce using rule 31 (expression -> term .)
    LE              reduce using rule 31 (expression -> term .)
    GE              reduce using rule 31 (expression -> term .)
    LT              reduce using rule 31 (expression -> term .)
    GT              reduce using rule 31 (expression -> term .)
    EQ              reduce using rule 31 (expression -> term .)
    NEQ             reduce using rule 31 (expression -> term .)
    AND             reduce using rule 31 (expression -> term .)
    RPAREN          reduce using rule 31 (expression -> term .)
    OR              reduce using rule 31 (expression -> term .)
    TIMES           shift and go to state 51


state 29

    (33) term -> factor .

    TIMES           reduce using rule 33 (term -> factor .)
    PLUS            reduce using rule 33 (term -> factor .)
    MINUS           reduce using rule 33 (term -> factor .)
    SEMICOLON       reduce using rule 33 (term -> factor .)
    LE              reduce using rule 33 (term -> factor .)
    GE              reduce using rule 33 (term -> factor .)
    LT              reduce using rule 33 (term -> factor .)
    GT              reduce using rule 33 (term -> factor .)
    EQ              reduce using rule 33 (term -> factor .)
    NEQ             reduce using rule 33 (term -> factor .)
    AND             reduce using rule 33 (term -> factor .)
    RPAREN          reduce using rule 33 (term -> factor .)
    OR              reduce using rule 33 (term -> factor .)


state 30

    (35) factor -> TRUE .

    TIMES           reduce using rule 35 (factor -> TRUE .)
    PLUS            reduce using rule 35 (factor -> TRUE .)
    MINUS           reduce using rule 35 (factor -> TRUE .)
    SEMICOLON       reduce using rule 35 (factor -> TRUE .)
    RPAREN          reduce using rule 35 (factor -> TRUE .)
    LE              reduce using rule 35 (factor -> TRUE .)
    GE              reduce using rule 35 (factor -> TRUE .)
    LT              reduce using rule 35 (factor -> TRUE .)
    GT              reduce using rule 35 (factor -> TRUE .)
    EQ              reduce using rule 35 (factor -> TRUE .)
    NEQ             reduce using rule 35 (factor -> TRUE .)
    AND             reduce using rule 35 (factor -> TRUE .)
    OR              reduce using rule 35 (factor -> TRUE .)


state 31

    (36) factor -> FALSE .

    TIMES           reduce using rule 36 (factor -> FALSE .)
    PLUS            reduce using rule 36 (factor -> FALSE .)
    MINUS           reduce using rule 36 (factor -> FALSE .)
    SEMICOLON       reduce using rule 36 (factor -> FALSE .)
    RPAREN          reduce using rule 36 (factor -> FALSE .)
    LE              reduce using rule 36 (factor -> FALSE .)
    GE              reduce using rule 36 (factor -> FALSE .)
    LT              reduce using rule 36 (factor -> FALSE .)
    GT              reduce using rule 36 (factor -> FALSE .)
    EQ              reduce using rule 36 (factor -> FALSE .)
    NEQ             reduce using rule 36 (factor -> FALSE .)
    AND             reduce using rule 36 (factor -> FALSE .)
    OR              reduce using rule 36 (factor -> FALSE .)


state 32

    (2) function -> INT ID LPAREN RPAREN LBRACE block RETURN NUMBER SEMICOLON . RBRACE

    RBRACE          shift and go to state 52


state 33

    (7) statement -> BOOL ID EQUAL . simple_expression SEMICOLON
    (28) simple_expression -> . expression
    (29) expression -> . expression PLUS term
    (30) expression -> . expression MINUS term
    (31) expression -> . term
    (32) term -> . term TIMES factor
    (33) term -> . factor
    (34) factor -> . NUMBER
    (35) factor -> . TRUE
    (36) factor -> . FALSE
    (37) factor -> . ID

    NUMBER          shift and go to state 43
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    ID              shift and go to state 24

    simple_expression              shift and go to state 53
    expression                     shift and go to state 27
    term                           shift and go to state 28
    factor                         shift and go to state 29

state 34

    (10) statement -> IF LPAREN logical_a . RPAREN LBRACE block RBRACE
    (12) logical_a -> logical_a . OR logical_b

    RPAREN          shift and go to state 54
    OR              shift and go to state 55


state 35

    (13) logical_a -> logical_b .
    (17) logical_b -> logical_b . AND logical_c

    RPAREN          reduce using rule 13 (logical_a -> logical_b .)
    OR              reduce using rule 13 (logical_a -> logical_b .)
    AND             shift and go to state 56


state 36

    (14) logical_a -> TRUE .
    (35) factor -> TRUE .

  ! reduce/reduce conflict for RPAREN resolved using rule 14 (logical_a -> TRUE .)
  ! reduce/reduce conflict for OR resolved using rule 14 (logical_a -> TRUE .)
    RPAREN          reduce using rule 14 (logical_a -> TRUE .)
    OR              reduce using rule 14 (logical_a -> TRUE .)
    TIMES           reduce using rule 35 (factor -> TRUE .)
    PLUS            reduce using rule 35 (factor -> TRUE .)
    MINUS           reduce using rule 35 (factor -> TRUE .)
    LE              reduce using rule 35 (factor -> TRUE .)
    GE              reduce using rule 35 (factor -> TRUE .)
    LT              reduce using rule 35 (factor -> TRUE .)
    GT              reduce using rule 35 (factor -> TRUE .)
    EQ              reduce using rule 35 (factor -> TRUE .)
    NEQ             reduce using rule 35 (factor -> TRUE .)
    AND             reduce using rule 35 (factor -> TRUE .)

  ! RPAREN          [ reduce using rule 35 (factor -> TRUE .) ]
  ! OR              [ reduce using rule 35 (factor -> TRUE .) ]


state 37

    (15) logical_a -> FALSE .
    (36) factor -> FALSE .

  ! reduce/reduce conflict for RPAREN resolved using rule 15 (logical_a -> FALSE .)
  ! reduce/reduce conflict for OR resolved using rule 15 (logical_a -> FALSE .)
    RPAREN          reduce using rule 15 (logical_a -> FALSE .)
    OR              reduce using rule 15 (logical_a -> FALSE .)
    TIMES           reduce using rule 36 (factor -> FALSE .)
    PLUS            reduce using rule 36 (factor -> FALSE .)
    MINUS           reduce using rule 36 (factor -> FALSE .)
    LE              reduce using rule 36 (factor -> FALSE .)
    GE              reduce using rule 36 (factor -> FALSE .)
    LT              reduce using rule 36 (factor -> FALSE .)
    GT              reduce using rule 36 (factor -> FALSE .)
    EQ              reduce using rule 36 (factor -> FALSE .)
    NEQ             reduce using rule 36 (factor -> FALSE .)
    AND             reduce using rule 36 (factor -> FALSE .)

  ! RPAREN          [ reduce using rule 36 (factor -> FALSE .) ]
  ! OR              [ reduce using rule 36 (factor -> FALSE .) ]


state 38

    (16) logical_a -> ID .
    (37) factor -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 16 (logical_a -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 16 (logical_a -> ID .)
    RPAREN          reduce using rule 16 (logical_a -> ID .)
    OR              reduce using rule 16 (logical_a -> ID .)
    TIMES           reduce using rule 37 (factor -> ID .)
    PLUS            reduce using rule 37 (factor -> ID .)
    MINUS           reduce using rule 37 (factor -> ID .)
    LE              reduce using rule 37 (factor -> ID .)
    GE              reduce using rule 37 (factor -> ID .)
    LT              reduce using rule 37 (factor -> ID .)
    GT              reduce using rule 37 (factor -> ID .)
    EQ              reduce using rule 37 (factor -> ID .)
    NEQ             reduce using rule 37 (factor -> ID .)
    AND             reduce using rule 37 (factor -> ID .)

  ! RPAREN          [ reduce using rule 37 (factor -> ID .) ]
  ! OR              [ reduce using rule 37 (factor -> ID .) ]


state 39

    (18) logical_b -> logical_c .
    (19) logical_c -> logical_c . EQ logical_d
    (20) logical_c -> logical_c . NEQ logical_d

    AND             reduce using rule 18 (logical_b -> logical_c .)
    RPAREN          reduce using rule 18 (logical_b -> logical_c .)
    OR              reduce using rule 18 (logical_b -> logical_c .)
    EQ              shift and go to state 57
    NEQ             shift and go to state 58


state 40

    (21) logical_c -> logical_d .
    (22) logical_d -> logical_d . LE marked_expression
    (23) logical_d -> logical_d . GE marked_expression
    (24) logical_d -> logical_d . LT marked_expression
    (25) logical_d -> logical_d . GT marked_expression

    EQ              reduce using rule 21 (logical_c -> logical_d .)
    NEQ             reduce using rule 21 (logical_c -> logical_d .)
    AND             reduce using rule 21 (logical_c -> logical_d .)
    RPAREN          reduce using rule 21 (logical_c -> logical_d .)
    OR              reduce using rule 21 (logical_c -> logical_d .)
    LE              shift and go to state 59
    GE              shift and go to state 60
    LT              shift and go to state 61
    GT              shift and go to state 62


state 41

    (27) logical_d -> marked_expression .

    LE              reduce using rule 27 (logical_d -> marked_expression .)
    GE              reduce using rule 27 (logical_d -> marked_expression .)
    LT              reduce using rule 27 (logical_d -> marked_expression .)
    GT              reduce using rule 27 (logical_d -> marked_expression .)
    EQ              reduce using rule 27 (logical_d -> marked_expression .)
    NEQ             reduce using rule 27 (logical_d -> marked_expression .)
    AND             reduce using rule 27 (logical_d -> marked_expression .)
    RPAREN          reduce using rule 27 (logical_d -> marked_expression .)
    OR              reduce using rule 27 (logical_d -> marked_expression .)


state 42

    (26) marked_expression -> expression .
    (29) expression -> expression . PLUS term
    (30) expression -> expression . MINUS term

    LE              reduce using rule 26 (marked_expression -> expression .)
    GE              reduce using rule 26 (marked_expression -> expression .)
    LT              reduce using rule 26 (marked_expression -> expression .)
    GT              reduce using rule 26 (marked_expression -> expression .)
    EQ              reduce using rule 26 (marked_expression -> expression .)
    NEQ             reduce using rule 26 (marked_expression -> expression .)
    AND             reduce using rule 26 (marked_expression -> expression .)
    RPAREN          reduce using rule 26 (marked_expression -> expression .)
    OR              reduce using rule 26 (marked_expression -> expression .)
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50


state 43

    (34) factor -> NUMBER .

    TIMES           reduce using rule 34 (factor -> NUMBER .)
    PLUS            reduce using rule 34 (factor -> NUMBER .)
    MINUS           reduce using rule 34 (factor -> NUMBER .)
    LE              reduce using rule 34 (factor -> NUMBER .)
    GE              reduce using rule 34 (factor -> NUMBER .)
    LT              reduce using rule 34 (factor -> NUMBER .)
    GT              reduce using rule 34 (factor -> NUMBER .)
    EQ              reduce using rule 34 (factor -> NUMBER .)
    NEQ             reduce using rule 34 (factor -> NUMBER .)
    AND             reduce using rule 34 (factor -> NUMBER .)
    RPAREN          reduce using rule 34 (factor -> NUMBER .)
    OR              reduce using rule 34 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 34 (factor -> NUMBER .)


state 44

    (11) statement -> PRINT LPAREN term . RPAREN SEMICOLON
    (32) term -> term . TIMES factor

    RPAREN          shift and go to state 63
    TIMES           shift and go to state 51


state 45

    (5) statement -> INT ID EQUAL NUMBER . SEMICOLON
    (34) factor -> NUMBER .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 64
    TIMES           reduce using rule 34 (factor -> NUMBER .)
    PLUS            reduce using rule 34 (factor -> NUMBER .)
    MINUS           reduce using rule 34 (factor -> NUMBER .)

  ! SEMICOLON       [ reduce using rule 34 (factor -> NUMBER .) ]


state 46

    (6) statement -> INT ID EQUAL simple_expression . SEMICOLON

    SEMICOLON       shift and go to state 65


state 47

    (8) statement -> ID EQUAL NUMBER SEMICOLON .

    RETURN          reduce using rule 8 (statement -> ID EQUAL NUMBER SEMICOLON .)
    INT             reduce using rule 8 (statement -> ID EQUAL NUMBER SEMICOLON .)
    BOOL            reduce using rule 8 (statement -> ID EQUAL NUMBER SEMICOLON .)
    ID              reduce using rule 8 (statement -> ID EQUAL NUMBER SEMICOLON .)
    IF              reduce using rule 8 (statement -> ID EQUAL NUMBER SEMICOLON .)
    PRINT           reduce using rule 8 (statement -> ID EQUAL NUMBER SEMICOLON .)
    RBRACE          reduce using rule 8 (statement -> ID EQUAL NUMBER SEMICOLON .)


state 48

    (9) statement -> ID EQUAL simple_expression SEMICOLON .

    RETURN          reduce using rule 9 (statement -> ID EQUAL simple_expression SEMICOLON .)
    INT             reduce using rule 9 (statement -> ID EQUAL simple_expression SEMICOLON .)
    BOOL            reduce using rule 9 (statement -> ID EQUAL simple_expression SEMICOLON .)
    ID              reduce using rule 9 (statement -> ID EQUAL simple_expression SEMICOLON .)
    IF              reduce using rule 9 (statement -> ID EQUAL simple_expression SEMICOLON .)
    PRINT           reduce using rule 9 (statement -> ID EQUAL simple_expression SEMICOLON .)
    RBRACE          reduce using rule 9 (statement -> ID EQUAL simple_expression SEMICOLON .)


state 49

    (29) expression -> expression PLUS . term
    (32) term -> . term TIMES factor
    (33) term -> . factor
    (34) factor -> . NUMBER
    (35) factor -> . TRUE
    (36) factor -> . FALSE
    (37) factor -> . ID

    NUMBER          shift and go to state 43
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    ID              shift and go to state 24

    term                           shift and go to state 66
    factor                         shift and go to state 29

state 50

    (30) expression -> expression MINUS . term
    (32) term -> . term TIMES factor
    (33) term -> . factor
    (34) factor -> . NUMBER
    (35) factor -> . TRUE
    (36) factor -> . FALSE
    (37) factor -> . ID

    NUMBER          shift and go to state 43
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    ID              shift and go to state 24

    term                           shift and go to state 67
    factor                         shift and go to state 29

state 51

    (32) term -> term TIMES . factor
    (34) factor -> . NUMBER
    (35) factor -> . TRUE
    (36) factor -> . FALSE
    (37) factor -> . ID

    NUMBER          shift and go to state 43
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    ID              shift and go to state 24

    factor                         shift and go to state 68

state 52

    (2) function -> INT ID LPAREN RPAREN LBRACE block RETURN NUMBER SEMICOLON RBRACE .

    $end            reduce using rule 2 (function -> INT ID LPAREN RPAREN LBRACE block RETURN NUMBER SEMICOLON RBRACE .)


state 53

    (7) statement -> BOOL ID EQUAL simple_expression . SEMICOLON

    SEMICOLON       shift and go to state 69


state 54

    (10) statement -> IF LPAREN logical_a RPAREN . LBRACE block RBRACE

    LBRACE          shift and go to state 70


state 55

    (12) logical_a -> logical_a OR . logical_b
    (17) logical_b -> . logical_b AND logical_c
    (18) logical_b -> . logical_c
    (19) logical_c -> . logical_c EQ logical_d
    (20) logical_c -> . logical_c NEQ logical_d
    (21) logical_c -> . logical_d
    (22) logical_d -> . logical_d LE marked_expression
    (23) logical_d -> . logical_d GE marked_expression
    (24) logical_d -> . logical_d LT marked_expression
    (25) logical_d -> . logical_d GT marked_expression
    (27) logical_d -> . marked_expression
    (26) marked_expression -> . expression
    (29) expression -> . expression PLUS term
    (30) expression -> . expression MINUS term
    (31) expression -> . term
    (32) term -> . term TIMES factor
    (33) term -> . factor
    (34) factor -> . NUMBER
    (35) factor -> . TRUE
    (36) factor -> . FALSE
    (37) factor -> . ID

    NUMBER          shift and go to state 43
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    ID              shift and go to state 24

    logical_b                      shift and go to state 71
    logical_c                      shift and go to state 39
    logical_d                      shift and go to state 40
    marked_expression              shift and go to state 41
    expression                     shift and go to state 42
    term                           shift and go to state 28
    factor                         shift and go to state 29

state 56

    (17) logical_b -> logical_b AND . logical_c
    (19) logical_c -> . logical_c EQ logical_d
    (20) logical_c -> . logical_c NEQ logical_d
    (21) logical_c -> . logical_d
    (22) logical_d -> . logical_d LE marked_expression
    (23) logical_d -> . logical_d GE marked_expression
    (24) logical_d -> . logical_d LT marked_expression
    (25) logical_d -> . logical_d GT marked_expression
    (27) logical_d -> . marked_expression
    (26) marked_expression -> . expression
    (29) expression -> . expression PLUS term
    (30) expression -> . expression MINUS term
    (31) expression -> . term
    (32) term -> . term TIMES factor
    (33) term -> . factor
    (34) factor -> . NUMBER
    (35) factor -> . TRUE
    (36) factor -> . FALSE
    (37) factor -> . ID

    NUMBER          shift and go to state 43
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    ID              shift and go to state 24

    logical_c                      shift and go to state 72
    logical_d                      shift and go to state 40
    marked_expression              shift and go to state 41
    expression                     shift and go to state 42
    term                           shift and go to state 28
    factor                         shift and go to state 29

state 57

    (19) logical_c -> logical_c EQ . logical_d
    (22) logical_d -> . logical_d LE marked_expression
    (23) logical_d -> . logical_d GE marked_expression
    (24) logical_d -> . logical_d LT marked_expression
    (25) logical_d -> . logical_d GT marked_expression
    (27) logical_d -> . marked_expression
    (26) marked_expression -> . expression
    (29) expression -> . expression PLUS term
    (30) expression -> . expression MINUS term
    (31) expression -> . term
    (32) term -> . term TIMES factor
    (33) term -> . factor
    (34) factor -> . NUMBER
    (35) factor -> . TRUE
    (36) factor -> . FALSE
    (37) factor -> . ID

    NUMBER          shift and go to state 43
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    ID              shift and go to state 24

    logical_d                      shift and go to state 73
    marked_expression              shift and go to state 41
    expression                     shift and go to state 42
    term                           shift and go to state 28
    factor                         shift and go to state 29

state 58

    (20) logical_c -> logical_c NEQ . logical_d
    (22) logical_d -> . logical_d LE marked_expression
    (23) logical_d -> . logical_d GE marked_expression
    (24) logical_d -> . logical_d LT marked_expression
    (25) logical_d -> . logical_d GT marked_expression
    (27) logical_d -> . marked_expression
    (26) marked_expression -> . expression
    (29) expression -> . expression PLUS term
    (30) expression -> . expression MINUS term
    (31) expression -> . term
    (32) term -> . term TIMES factor
    (33) term -> . factor
    (34) factor -> . NUMBER
    (35) factor -> . TRUE
    (36) factor -> . FALSE
    (37) factor -> . ID

    NUMBER          shift and go to state 43
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    ID              shift and go to state 24

    logical_d                      shift and go to state 74
    marked_expression              shift and go to state 41
    expression                     shift and go to state 42
    term                           shift and go to state 28
    factor                         shift and go to state 29

state 59

    (22) logical_d -> logical_d LE . marked_expression
    (26) marked_expression -> . expression
    (29) expression -> . expression PLUS term
    (30) expression -> . expression MINUS term
    (31) expression -> . term
    (32) term -> . term TIMES factor
    (33) term -> . factor
    (34) factor -> . NUMBER
    (35) factor -> . TRUE
    (36) factor -> . FALSE
    (37) factor -> . ID

    NUMBER          shift and go to state 43
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    ID              shift and go to state 24

    marked_expression              shift and go to state 75
    expression                     shift and go to state 42
    term                           shift and go to state 28
    factor                         shift and go to state 29

state 60

    (23) logical_d -> logical_d GE . marked_expression
    (26) marked_expression -> . expression
    (29) expression -> . expression PLUS term
    (30) expression -> . expression MINUS term
    (31) expression -> . term
    (32) term -> . term TIMES factor
    (33) term -> . factor
    (34) factor -> . NUMBER
    (35) factor -> . TRUE
    (36) factor -> . FALSE
    (37) factor -> . ID

    NUMBER          shift and go to state 43
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    ID              shift and go to state 24

    marked_expression              shift and go to state 76
    expression                     shift and go to state 42
    term                           shift and go to state 28
    factor                         shift and go to state 29

state 61

    (24) logical_d -> logical_d LT . marked_expression
    (26) marked_expression -> . expression
    (29) expression -> . expression PLUS term
    (30) expression -> . expression MINUS term
    (31) expression -> . term
    (32) term -> . term TIMES factor
    (33) term -> . factor
    (34) factor -> . NUMBER
    (35) factor -> . TRUE
    (36) factor -> . FALSE
    (37) factor -> . ID

    NUMBER          shift and go to state 43
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    ID              shift and go to state 24

    marked_expression              shift and go to state 77
    expression                     shift and go to state 42
    term                           shift and go to state 28
    factor                         shift and go to state 29

state 62

    (25) logical_d -> logical_d GT . marked_expression
    (26) marked_expression -> . expression
    (29) expression -> . expression PLUS term
    (30) expression -> . expression MINUS term
    (31) expression -> . term
    (32) term -> . term TIMES factor
    (33) term -> . factor
    (34) factor -> . NUMBER
    (35) factor -> . TRUE
    (36) factor -> . FALSE
    (37) factor -> . ID

    NUMBER          shift and go to state 43
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    ID              shift and go to state 24

    marked_expression              shift and go to state 78
    expression                     shift and go to state 42
    term                           shift and go to state 28
    factor                         shift and go to state 29

state 63

    (11) statement -> PRINT LPAREN term RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 79


state 64

    (5) statement -> INT ID EQUAL NUMBER SEMICOLON .

    RETURN          reduce using rule 5 (statement -> INT ID EQUAL NUMBER SEMICOLON .)
    INT             reduce using rule 5 (statement -> INT ID EQUAL NUMBER SEMICOLON .)
    BOOL            reduce using rule 5 (statement -> INT ID EQUAL NUMBER SEMICOLON .)
    ID              reduce using rule 5 (statement -> INT ID EQUAL NUMBER SEMICOLON .)
    IF              reduce using rule 5 (statement -> INT ID EQUAL NUMBER SEMICOLON .)
    PRINT           reduce using rule 5 (statement -> INT ID EQUAL NUMBER SEMICOLON .)
    RBRACE          reduce using rule 5 (statement -> INT ID EQUAL NUMBER SEMICOLON .)


state 65

    (6) statement -> INT ID EQUAL simple_expression SEMICOLON .

    RETURN          reduce using rule 6 (statement -> INT ID EQUAL simple_expression SEMICOLON .)
    INT             reduce using rule 6 (statement -> INT ID EQUAL simple_expression SEMICOLON .)
    BOOL            reduce using rule 6 (statement -> INT ID EQUAL simple_expression SEMICOLON .)
    ID              reduce using rule 6 (statement -> INT ID EQUAL simple_expression SEMICOLON .)
    IF              reduce using rule 6 (statement -> INT ID EQUAL simple_expression SEMICOLON .)
    PRINT           reduce using rule 6 (statement -> INT ID EQUAL simple_expression SEMICOLON .)
    RBRACE          reduce using rule 6 (statement -> INT ID EQUAL simple_expression SEMICOLON .)


state 66

    (29) expression -> expression PLUS term .
    (32) term -> term . TIMES factor

    PLUS            reduce using rule 29 (expression -> expression PLUS term .)
    MINUS           reduce using rule 29 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 29 (expression -> expression PLUS term .)
    LE              reduce using rule 29 (expression -> expression PLUS term .)
    GE              reduce using rule 29 (expression -> expression PLUS term .)
    LT              reduce using rule 29 (expression -> expression PLUS term .)
    GT              reduce using rule 29 (expression -> expression PLUS term .)
    EQ              reduce using rule 29 (expression -> expression PLUS term .)
    NEQ             reduce using rule 29 (expression -> expression PLUS term .)
    AND             reduce using rule 29 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 29 (expression -> expression PLUS term .)
    OR              reduce using rule 29 (expression -> expression PLUS term .)
    TIMES           shift and go to state 51


state 67

    (30) expression -> expression MINUS term .
    (32) term -> term . TIMES factor

    PLUS            reduce using rule 30 (expression -> expression MINUS term .)
    MINUS           reduce using rule 30 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 30 (expression -> expression MINUS term .)
    LE              reduce using rule 30 (expression -> expression MINUS term .)
    GE              reduce using rule 30 (expression -> expression MINUS term .)
    LT              reduce using rule 30 (expression -> expression MINUS term .)
    GT              reduce using rule 30 (expression -> expression MINUS term .)
    EQ              reduce using rule 30 (expression -> expression MINUS term .)
    NEQ             reduce using rule 30 (expression -> expression MINUS term .)
    AND             reduce using rule 30 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 30 (expression -> expression MINUS term .)
    OR              reduce using rule 30 (expression -> expression MINUS term .)
    TIMES           shift and go to state 51


state 68

    (32) term -> term TIMES factor .

    TIMES           reduce using rule 32 (term -> term TIMES factor .)
    PLUS            reduce using rule 32 (term -> term TIMES factor .)
    MINUS           reduce using rule 32 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 32 (term -> term TIMES factor .)
    LE              reduce using rule 32 (term -> term TIMES factor .)
    GE              reduce using rule 32 (term -> term TIMES factor .)
    LT              reduce using rule 32 (term -> term TIMES factor .)
    GT              reduce using rule 32 (term -> term TIMES factor .)
    EQ              reduce using rule 32 (term -> term TIMES factor .)
    NEQ             reduce using rule 32 (term -> term TIMES factor .)
    AND             reduce using rule 32 (term -> term TIMES factor .)
    RPAREN          reduce using rule 32 (term -> term TIMES factor .)
    OR              reduce using rule 32 (term -> term TIMES factor .)


state 69

    (7) statement -> BOOL ID EQUAL simple_expression SEMICOLON .

    RETURN          reduce using rule 7 (statement -> BOOL ID EQUAL simple_expression SEMICOLON .)
    INT             reduce using rule 7 (statement -> BOOL ID EQUAL simple_expression SEMICOLON .)
    BOOL            reduce using rule 7 (statement -> BOOL ID EQUAL simple_expression SEMICOLON .)
    ID              reduce using rule 7 (statement -> BOOL ID EQUAL simple_expression SEMICOLON .)
    IF              reduce using rule 7 (statement -> BOOL ID EQUAL simple_expression SEMICOLON .)
    PRINT           reduce using rule 7 (statement -> BOOL ID EQUAL simple_expression SEMICOLON .)
    RBRACE          reduce using rule 7 (statement -> BOOL ID EQUAL simple_expression SEMICOLON .)


state 70

    (10) statement -> IF LPAREN logical_a RPAREN LBRACE . block RBRACE
    (3) block -> . block statement
    (4) block -> . empty
    (38) empty -> .

    RBRACE          reduce using rule 38 (empty -> .)
    INT             reduce using rule 38 (empty -> .)
    BOOL            reduce using rule 38 (empty -> .)
    ID              reduce using rule 38 (empty -> .)
    IF              reduce using rule 38 (empty -> .)
    PRINT           reduce using rule 38 (empty -> .)

    block                          shift and go to state 80
    empty                          shift and go to state 9

state 71

    (12) logical_a -> logical_a OR logical_b .
    (17) logical_b -> logical_b . AND logical_c

    RPAREN          reduce using rule 12 (logical_a -> logical_a OR logical_b .)
    OR              reduce using rule 12 (logical_a -> logical_a OR logical_b .)
    AND             shift and go to state 56


state 72

    (17) logical_b -> logical_b AND logical_c .
    (19) logical_c -> logical_c . EQ logical_d
    (20) logical_c -> logical_c . NEQ logical_d

    AND             reduce using rule 17 (logical_b -> logical_b AND logical_c .)
    RPAREN          reduce using rule 17 (logical_b -> logical_b AND logical_c .)
    OR              reduce using rule 17 (logical_b -> logical_b AND logical_c .)
    EQ              shift and go to state 57
    NEQ             shift and go to state 58


state 73

    (19) logical_c -> logical_c EQ logical_d .
    (22) logical_d -> logical_d . LE marked_expression
    (23) logical_d -> logical_d . GE marked_expression
    (24) logical_d -> logical_d . LT marked_expression
    (25) logical_d -> logical_d . GT marked_expression

    EQ              reduce using rule 19 (logical_c -> logical_c EQ logical_d .)
    NEQ             reduce using rule 19 (logical_c -> logical_c EQ logical_d .)
    AND             reduce using rule 19 (logical_c -> logical_c EQ logical_d .)
    RPAREN          reduce using rule 19 (logical_c -> logical_c EQ logical_d .)
    OR              reduce using rule 19 (logical_c -> logical_c EQ logical_d .)
    LE              shift and go to state 59
    GE              shift and go to state 60
    LT              shift and go to state 61
    GT              shift and go to state 62


state 74

    (20) logical_c -> logical_c NEQ logical_d .
    (22) logical_d -> logical_d . LE marked_expression
    (23) logical_d -> logical_d . GE marked_expression
    (24) logical_d -> logical_d . LT marked_expression
    (25) logical_d -> logical_d . GT marked_expression

    EQ              reduce using rule 20 (logical_c -> logical_c NEQ logical_d .)
    NEQ             reduce using rule 20 (logical_c -> logical_c NEQ logical_d .)
    AND             reduce using rule 20 (logical_c -> logical_c NEQ logical_d .)
    RPAREN          reduce using rule 20 (logical_c -> logical_c NEQ logical_d .)
    OR              reduce using rule 20 (logical_c -> logical_c NEQ logical_d .)
    LE              shift and go to state 59
    GE              shift and go to state 60
    LT              shift and go to state 61
    GT              shift and go to state 62


state 75

    (22) logical_d -> logical_d LE marked_expression .

    LE              reduce using rule 22 (logical_d -> logical_d LE marked_expression .)
    GE              reduce using rule 22 (logical_d -> logical_d LE marked_expression .)
    LT              reduce using rule 22 (logical_d -> logical_d LE marked_expression .)
    GT              reduce using rule 22 (logical_d -> logical_d LE marked_expression .)
    EQ              reduce using rule 22 (logical_d -> logical_d LE marked_expression .)
    NEQ             reduce using rule 22 (logical_d -> logical_d LE marked_expression .)
    AND             reduce using rule 22 (logical_d -> logical_d LE marked_expression .)
    RPAREN          reduce using rule 22 (logical_d -> logical_d LE marked_expression .)
    OR              reduce using rule 22 (logical_d -> logical_d LE marked_expression .)


state 76

    (23) logical_d -> logical_d GE marked_expression .

    LE              reduce using rule 23 (logical_d -> logical_d GE marked_expression .)
    GE              reduce using rule 23 (logical_d -> logical_d GE marked_expression .)
    LT              reduce using rule 23 (logical_d -> logical_d GE marked_expression .)
    GT              reduce using rule 23 (logical_d -> logical_d GE marked_expression .)
    EQ              reduce using rule 23 (logical_d -> logical_d GE marked_expression .)
    NEQ             reduce using rule 23 (logical_d -> logical_d GE marked_expression .)
    AND             reduce using rule 23 (logical_d -> logical_d GE marked_expression .)
    RPAREN          reduce using rule 23 (logical_d -> logical_d GE marked_expression .)
    OR              reduce using rule 23 (logical_d -> logical_d GE marked_expression .)


state 77

    (24) logical_d -> logical_d LT marked_expression .

    LE              reduce using rule 24 (logical_d -> logical_d LT marked_expression .)
    GE              reduce using rule 24 (logical_d -> logical_d LT marked_expression .)
    LT              reduce using rule 24 (logical_d -> logical_d LT marked_expression .)
    GT              reduce using rule 24 (logical_d -> logical_d LT marked_expression .)
    EQ              reduce using rule 24 (logical_d -> logical_d LT marked_expression .)
    NEQ             reduce using rule 24 (logical_d -> logical_d LT marked_expression .)
    AND             reduce using rule 24 (logical_d -> logical_d LT marked_expression .)
    RPAREN          reduce using rule 24 (logical_d -> logical_d LT marked_expression .)
    OR              reduce using rule 24 (logical_d -> logical_d LT marked_expression .)


state 78

    (25) logical_d -> logical_d GT marked_expression .

    LE              reduce using rule 25 (logical_d -> logical_d GT marked_expression .)
    GE              reduce using rule 25 (logical_d -> logical_d GT marked_expression .)
    LT              reduce using rule 25 (logical_d -> logical_d GT marked_expression .)
    GT              reduce using rule 25 (logical_d -> logical_d GT marked_expression .)
    EQ              reduce using rule 25 (logical_d -> logical_d GT marked_expression .)
    NEQ             reduce using rule 25 (logical_d -> logical_d GT marked_expression .)
    AND             reduce using rule 25 (logical_d -> logical_d GT marked_expression .)
    RPAREN          reduce using rule 25 (logical_d -> logical_d GT marked_expression .)
    OR              reduce using rule 25 (logical_d -> logical_d GT marked_expression .)


state 79

    (11) statement -> PRINT LPAREN term RPAREN SEMICOLON .

    RETURN          reduce using rule 11 (statement -> PRINT LPAREN term RPAREN SEMICOLON .)
    INT             reduce using rule 11 (statement -> PRINT LPAREN term RPAREN SEMICOLON .)
    BOOL            reduce using rule 11 (statement -> PRINT LPAREN term RPAREN SEMICOLON .)
    ID              reduce using rule 11 (statement -> PRINT LPAREN term RPAREN SEMICOLON .)
    IF              reduce using rule 11 (statement -> PRINT LPAREN term RPAREN SEMICOLON .)
    PRINT           reduce using rule 11 (statement -> PRINT LPAREN term RPAREN SEMICOLON .)
    RBRACE          reduce using rule 11 (statement -> PRINT LPAREN term RPAREN SEMICOLON .)


state 80

    (10) statement -> IF LPAREN logical_a RPAREN LBRACE block . RBRACE
    (3) block -> block . statement
    (5) statement -> . INT ID EQUAL NUMBER SEMICOLON
    (6) statement -> . INT ID EQUAL simple_expression SEMICOLON
    (7) statement -> . BOOL ID EQUAL simple_expression SEMICOLON
    (8) statement -> . ID EQUAL NUMBER SEMICOLON
    (9) statement -> . ID EQUAL simple_expression SEMICOLON
    (10) statement -> . IF LPAREN logical_a RPAREN LBRACE block RBRACE
    (11) statement -> . PRINT LPAREN term RPAREN SEMICOLON

    RBRACE          shift and go to state 81
    INT             shift and go to state 10
    BOOL            shift and go to state 14
    ID              shift and go to state 11
    IF              shift and go to state 15
    PRINT           shift and go to state 16

    statement                      shift and go to state 13

state 81

    (10) statement -> IF LPAREN logical_a RPAREN LBRACE block RBRACE .

    RETURN          reduce using rule 10 (statement -> IF LPAREN logical_a RPAREN LBRACE block RBRACE .)
    INT             reduce using rule 10 (statement -> IF LPAREN logical_a RPAREN LBRACE block RBRACE .)
    BOOL            reduce using rule 10 (statement -> IF LPAREN logical_a RPAREN LBRACE block RBRACE .)
    ID              reduce using rule 10 (statement -> IF LPAREN logical_a RPAREN LBRACE block RBRACE .)
    IF              reduce using rule 10 (statement -> IF LPAREN logical_a RPAREN LBRACE block RBRACE .)
    PRINT           reduce using rule 10 (statement -> IF LPAREN logical_a RPAREN LBRACE block RBRACE .)
    RBRACE          reduce using rule 10 (statement -> IF LPAREN logical_a RPAREN LBRACE block RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SEMICOLON in state 25 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 45 resolved as shift
WARNING: reduce/reduce conflict in state 36 resolved using rule (logical_a -> TRUE)
WARNING: rejected rule (factor -> TRUE) in state 36
WARNING: reduce/reduce conflict in state 37 resolved using rule (logical_a -> FALSE)
WARNING: rejected rule (factor -> FALSE) in state 37
WARNING: reduce/reduce conflict in state 38 resolved using rule (logical_a -> ID)
WARNING: rejected rule (factor -> ID) in state 38
